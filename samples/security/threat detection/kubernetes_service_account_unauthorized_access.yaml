metadata:
  version: "1"
  dependencies:
    apps:
      - id: dynatrace.automations
        version: ^1.1987.0
  inputs: []
workflow:
  title: Kubernetes service account unauthorized access
  tasks:
    execute_query:
      name: execute_query
      description: Execute DQL to find unauthorized activity
      action: dynatrace.automations:execute-dql-query
      input:
        query: >
          fetch logs, 
            from: -15m, 
            to: -5m, 
            scanLimitGBytes: -1

          // MS AKS

          | parse content,
          "JSON{JSON{STRING+:log}(flat=true):properties}(flat=true)",
            parsingPrerequisite: (
              azure.resource.type == "MICROSOFT.CONTAINERSERVICE/MANAGEDCLUSTERS" and 
              log.source == "kube-audit"
            )
          | fieldsAdd content=coalesce(properties, content)


          | parse content, "JSON{
            STRING+:kind,
            STRING+:apiVersion,
            STRING+:level,
            STRING+:auditID,
            STRING+:stage,
            STRING+:requestURI,
            STRING:verb,
            JSON:user,
            JSON_ARRAY{ipaddr}(typed=true):sourceIPs,
            STRING+:userAgent,
            JSON:objectRef,
            JSON:responseStatus,
            TIMESTAMP('yyyy-MM-ddTHH:mm:ss.SZ'):requestReceivedTimestamp,
            TIMESTAMP('yyyy-MM-ddTHH:mm:ss.SZ'):stageTimestamp,
            JSON:annotations
            }(flat=true)"

          // filter on denied requests of service accounts trying to access
          configmaps and/or secrets 

          | filter 
            apiVersion == "audit.k8s.io/v1" and
            startsWith(user[username], "system:serviceaccount:") and
            in(verb, {"list", "get", "watch"}) and
            in(objectRef[resource], {"configmaps", "secrets"}) and
            responseStatus[reason] == "Forbidden"

          | fieldsAdd user.name = user[username]

          | fieldsAdd user.id = user[uid]

          | fieldsAdd actor.ips = sourceIPs

          | fieldsAdd k8s.pod.uid =
          user[extra][`authentication.kubernetes.io/pod-uid`]

          | expand k8s.pod.uid


          | join [
              fetch dt.entity.cloud_application_instance
              | fieldsAdd k8s.pod.uid = resourceUid
              | fieldsAdd k8s.pod.name = entity.name
              | fieldsAdd k8s.pod.ip = toIp(internalIpAddresses[])
              | fieldsAdd k8s.namespace.name = namespaceName
              | fieldsAdd dt.entity.kubernetes_cluster = clustered_by[dt.entity.kubernetes_cluster]
              | fieldsAdd k8s.cluster.name = entityName(dt.entity.kubernetes_cluster)
              | fieldsAdd k8s.cluster.uid = entityAttr(dt.entity.kubernetes_cluster, "kubernetesClusterId")
            ],
            kind: leftOuter,
            on: { k8s.pod.uid },
            fields: { k8s.cluster.name, k8s.cluster.uid, k8s.pod.name, k8s.pod.ip, k8s.namespace.name }

          | summarize { 
              finding.evidence.count = count(), 
              finding.evidence=collectDistinct(content)
            }, 
            by: {
              k8s.cluster.name, 
              k8s.cluster.uid, 
              k8s.pod.name,
              k8s.pod.uid,
              k8s.pod.ip, 
              k8s.namespace.name,
              cloud.provider,
              cloud.account.id,
              cloud.region,
              user.name,
              user.id,
              actor.ips
          }


          | fieldsAdd object.name = k8s.pod.name

          | fieldsAdd object.id = k8s.pod.uid

          | fieldsAdd object.type = "K8S_POD"

          | fieldsAdd finding.title = "Kubernetes service account unauthorized
          access"

          | fieldsAdd finding.description = concat("Unauthorized access attempt
          by service account ", `user.name`)

          | fieldsAdd finding.score = toDouble(6.9)

          | fieldsAdd finding.severity = "MEDIUM"

          | fieldsAdd finding.time.created = toTimestamp(now())

          | fieldsAdd finding.id =
          hashSha256(concat(toString(finding.time.created), toString(random())))

          | fieldsAdd actor.ips = arrayDistinct(arrayConcat(actor.ips,
          k8s.pod.ip))

          | fieldsAdd dt.security.risk.level = finding.severity

          | fieldsAdd dt.security.risk.score = finding.score

          | fieldsAdd event.id = finding.id

          | fieldsAdd detection.id = "4e63d2d7-0ef1-4cfa-924e-dc08a17a8b3f"

          | fieldsAdd detection.tags = array("kubernetes")

          | fieldsAdd mitre.attack.enterprise.tactic.ids = array("TA0006")

          | fieldsAdd mitre.attack.enterprise.technique.ids = array("T1552.007")
      position:
        x: 0
        y: 1
      predecessors: []
    apply_allowlist:
      name: apply_allowlist
      description: Prevent the creation of false positives
      action: dynatrace.automations:run-javascript
      input:
        script: >
          import { result } from '@dynatrace-sdk/automation-utils';


          const allowlist = [
            { "k8s.cluster.name": "not-existing-example-714e232d", "k8s.pod.uid": "example-e9c45d6d-e580-4dda-913b-ff1cbe43b1de"},
            { "k8s.workload.name": "not-existing-example-714e232d", "some.other.field": "example-xyz"}
          ]


          export default async function () {
            const results = await result('execute_query');
            const filteredResults: object[] = [];

            results.records.forEach(record => {
              const matchesAnyAllowlistEntry = allowlist.some(allowlistEntry => {
                  return Object.entries(allowlistEntry).every(([key, value]) => 
                      record[key] === value
                  );   
              });
              
              if (!matchesAnyAllowlistEntry) {
                filteredResults.push(record);
              }
            });
            return filteredResults;
          }
      position:
        x: 0
        y: 2
      predecessors:
        - execute_query
      conditions:
        states:
          execute_query: SUCCESS
    ingest_findings:
      name: ingest_findings
      description: Ingest events using OpenPipeline
      action: dynatrace.automations:http-function
      input:
        url: '{{ environment().url | replace(".apps.", ".")
          }}/platform/ingest/v1/security.events'
        method: POST
        payload: '{{ result("prepare_findings") }}'
        credential:
          type: token
          tokenPrefix: Api-Token
          credentialId: CREDENTIALS_VAULT-D51F20C35D6D104C
        failOnResponseCodes: 400-599
      position:
        x: 0
        y: 4
      predecessors:
        - prepare_findings
      conditions:
        states:
          prepare_findings: SUCCESS
        custom: |
          {{ result("prepare_findings")|length > 0 }}
    prepare_findings:
      name: prepare_findings
      description: Ensure semantic dictionary compliance
      action: dynatrace.automations:run-javascript
      input:
        script: |
          import { result } from '@dynatrace-sdk/automation-utils';

          export default async function () {
            var results = await result('apply_allowlist');
            results.forEach (record => {
              record["event.type"]        = "DETECTION_FINDING";
              record["event.provider"]    = "AutomationEngine";
              record["detection.action"]  = "OBSERVED";
              record["detection.type"]    = "DQL";
              record["finding.type"]      = "DQL";
              record["product.vendor"]    = "Dynatrace";
              record["product.name"]      = "AutomationEngine";
            });
            return results;
          }
      position:
        x: 0
        y: 3
      predecessors:
        - apply_allowlist
      conditions:
        states:
          apply_allowlist: SUCCESS
  description: ""
  trigger:
    schedule:
      rule: null
      trigger:
        type: interval
        intervalMinutes: 10
      timezone: UTC
      isActive: true
      isFaulty: false
      filterParameters: {}
      inputs: {}
  schemaVersion: 3
  result: null
  input: {}
  hourlyExecutionLimit: 1000
  type: STANDARD

